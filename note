#!/bin/bash

# This script is used to create a new note in the notes file

# Set the notes directory

NOTES_FILE="$HOME/.note"
if [[ ! -f "$NOTES_FILE" ]]; then
  touch "$NOTES_FILE"
fi

note_show_help () {
  cat << EOF
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

  Usage: note [OPTIONS] -- [NOTE]      

--------------------------------------------------------------------------------

  Summary:
    Manage, filter, and display notes from anywhere in your terminal.

--------------------------------------------------------------------------------

  Options:

    GENERAL FILTERING:
      -a,  --after        DATE    Include notes strictly after DATE 
      -b,  --before       DATE    Include notes strictly before DATE 
      -d,  --date         DATE    Include notes exactly on DATE 
      -m,  --message      STRING  Include notes matching STRING
      -R,  --git-repo     NAME    Include notes from git repository NAME
      -B,  --git-branch   NAME    Include notes from git branch NAME

    SPECIAL FILTERING:
      -l,  --last [N]     Display the last matching note only.
                          If N is given, display the last N notes.
      -g,  --git          Shorthand for "-r -B" (current repo/branch).
      -x,  --not          Invert the following option.

    OTHER:
      -e, --edit          Edit the output in \$EDITOR.
      -f, --file          Read notes from a file.
      -s, --short         Display only the note text (no metadata).
      -E, --edit-notes    Edit the source \$NOTES_FILE in \$EDITOR.
      -X, --extract       Remove the matching notes from the notes file.
      -I, --interactive   Read notes from the user interactively.
      --help              Display this help and exit.
      --info              Display information about this script and exit.
      --version           Display version information and exit.

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
EOF
}

note_show_info () {
  cat << EOF
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

  Description:

    FILTERING:
      - Selects for notes matching all given options (logical AND).
      - If no options are given, no filtering is performed, and nothing is 
          displayed.
      - Dates may be in the format YYYY-MM-DD or YYYY-MM or YYYY.
      - If optional arguments are omitted, the 'current' value is used.
      - All string matching is done via regular expressions. You can use 
        standard regex metacharacters. To match a literal metacharacter,
        escape it with a backslash.

    NOTES:
      - A note must be preceded by the "--" option, to avoid ambiguity.
      - If no "--" is given, or the note is empty, no note is added.
      - If the current directory is inside a git repository, the repository 
          name and current branch are automatically recorded.
      - Username, date, and time of note are also recorded.


--------------------------------------------------------------------------------

  Examples:

    note -- "my new note"       Add the note "my new note" to the notes file.
    note -m "string"            Display all notes matching "string".
    note -a 2023                Display all notes from the year 2023 onwards.
    note -e -d                  Display today's notes in the editor.
    note -d 2020-01 -- "text"   Display all notes from January 2020,
                                  then add the note "text" to the notes file.
    note -d -X -s               Silently delete all notes from today.
    note -b 2020-03 -xd 2018-01-10 -m "string1|string2" 
                                Display all notes from before March 2020, 
                                  excluding those from 10 January 2018,
                                  and which match "string1" or "string2".
    note -X -l10 -r "my_repo" -xB "hotfix" -m "feature" >> TODO.md
                                Find the last ten notes which are:
                                  from the git repository "my_repo"; 
                                  excluding those from the branch "hotfix";
                                  and which match "feature". 
                                  append them to the TODO.md file,
                                  and delete them from the notes file.

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
EOF
}

note_show_version () {
  cat << EOF
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

  note version 1.2
  
  Author:  Michael C. Cromer
  License: GNU General Public License v3.0

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
EOF
}


note_verify_date () {
  local date="$1"
  if ! [[ $date =~ ^[0-9]{4}(-[0-9]{2}){0,2}$ ]]; then
    echo "Invalid date format (must be YYYY[-MM[-DD]]): $date" >&2
    exit 1
  fi
}


note_parse_line () {
  local input="$1"
  input="$(echo "$input" | tr -d '\t' )"
  input="$(sed 's/[\*;&<>`|]/\\&/g' <<< "$input")"
  echo "$input"
}


note_is_repo () {
  git rev-parse --is-inside-work-tree &> /dev/null
}


note_write_line() {
    [[ -z "$1" ]] && return
    local d="$(date '+%Y-%m-%d')"
    local t="$(date '+%H:%M:%S')"
    local u="$(whoami)"
    if [[ note_is_repo ]]; then
        local g="$(git rev-parse --show-toplevel 2> /dev/null)"
        local r="$(basename "$g")"
        local b="$(git branch --show-current)"
    else
        local r="none"
        local b="none"
    fi
    printf "$d\t$t\t$u\t$r\t$b\t--\t$(note_parse_line "$1")" >> "$NOTES_FILE"
}


note_read_stdin() {
    while IFS= read -r line; do
        note_write_line "$line"
    done < /dev/stdin
}


note_main () {
    if [[ $# -eq 0 ]]; then
      note_show_help
      exit 1
    fi

    if [[ $1 == "--help" ]]; then
      note_show_help
      exit 0
    elif [[ $1 == "--info" ]]; then
      note_show_info
      exit 0
    elif [[ $1 == "--version" ]]; then
      note_show_version
      exit 0
    fi

    while [[ $# -gt 0 ]]; do
        local option="$1"
        shift 1

        if [[ "$option" == "--" ]]; then
            if [[ $# -eq 1 ]]; then
                note_read_stdin
            else
                note_write_line "$*"
            fi
            exit 0
        fi

        if [[ "$option" =~ ^"-x".+ || "$option" =~ ^"--not-".+ ]]; then
            local flag_not=1
            option="${option/-x/-}"
            option="${option/--not-/}"
        fi

        if [[ "$option" == "-x" || "$option" == "--not" ]]; then
            [[ $flag_not -eq 1 ]] && printf "Two wrongs don't make a right.\n" >&2 && exit 1
            local flag_not=1

        elif [[ "$option" == "-a" || "$option" == "--after" ]]; then
            local flag_output=1
            note_verify_date "$1"
            if [[ $flag_not -eq 1 ]]; then
                local args_not_after=( "${args_not_after[@]}" "$1" )
                flag_not=0
            else
                local args_after=( "${args_after[@]}" "$1" )
            fi
            shift 1

        elif [[ "$option" == "-b" || "$option" == "--before" ]]; then
            local flag_output=1
            note_verify_date "$1"
            if [[ $flag_not -eq 1 ]]; then
                local args_not_before=( "${args_not_before[@]}" "$1" )
                flag_not=0
            else
                local args_before=( "${args_before[@]}" "$1" )
            fi
            shift 1

        elif [[ "$option" == "-d" || "$option" == "--date" ]]; then
            local flag_output=1
            note_verify_date "$1"
            if [[ $flag_not -eq 1 ]]; then
                local args_not_date=( "${args_not_date[@]}" "$1" )
                flag_not=0
            else
                local args_date=( "${args_date[@]}" "$1" )
            fi
            shift 1

        elif [[ "$option" == "-m" || "$option" == "--message" ]]; then
            local flag_output=1
            if [[ $flag_not -eq 1 ]]; then
                local args_not_message=( "${args_not_message[@]}" "$1" )
                flag_not=0
            else
                local args_message=( "${args_message[@]}" "$1" )
            fi
            shift 1

        else 
            printf "Invalid option: $option\n" >&2
            exit 1
        fi

    done

    # If nothing has been done to produce output, exit early
    if [[ -z "${flag_output}" ]]; then
        exit 0
    fi

    # If we have gotten this far, we need to output something
    local notes="$(cat "$NOTES_FILE")"

    for after in "${args_after[@]}"; do
        notes="$(awk -v a="$after" -F '\t' '$1 > a' <<< "$notes")"
    done
    for after in "${args_not_after[@]}"; do
        notes="$(awk -v a="$after" -F '\t' '$1 <= a' <<< "$notes")"
    done

    for before in "${args_before[@]}"; do
        notes="$(awk -v b="$before" -F '\t' '$1 > b' <<< "$notes")"
    done
    for before in "${args_not_before[@]}"; do
        notes="$(awk -v b="$before" -F '\t' '$1 <= b' <<< "$notes")"
    done

    if [[ -n "${args_date[@]}" ]]; then
        local mask_date="$(IFS='|'; echo "${args_date[*]}")"
        notes="$(awk -v d="$mask_date" -F '\t' '$1 ~ d' <<< "$notes")"
    fi
    if [[ -n "${args_not_date[@]}" ]]; then
        local mask_date="$(IFS='|'; echo "${args_not_date[*]}")"
        notes="$(awk -v d="$mask_date" -F '\t' '$1 !~ d' <<< "$notes")"
    fi

    if [[ -n "${args_message[@]}" ]]; then
        local mask_message="$(IFS='|'; echo "${args_message[*]}")"
        notes="$(awk -v m="$mask_message" -F '\t' '$7 ~ m' <<< "$notes")"
    fi
    if [[ -n "${args_not_message[@]}" ]]; then
        local mask_message="$(IFS='|'; echo "${args_not_message[*]}")"
        notes="$(awk -v m="$mask_message" -F '\t' '$7 !~ m' <<< "$notes")"
    fi

    printf "%s\n" "$notes" | column -t -s $'\t'
}

note_main "$@"
